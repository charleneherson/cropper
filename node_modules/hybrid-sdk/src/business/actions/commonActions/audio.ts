import { hybrid as handleHybrid, createHybridCallback } from '../../../utils/iframeHybrid'
import Type from '../../../utils/type'
import tools from '../../../utils/tool'
import {
  SUCCESS,
  ERROR,
  COMPLETE,
  NOT_FOUND,
  INTERRUPT
} from '../../../utils/statusCode'

// interface Window {
//   [propName: string]: any;
//   [propName: number]: any;
// }

/**
 * @description 开始录音
 * @param {Function} callback 回调方法
 */
interface startRecordParams {
  wordType: number;         // 先声评测题的类型:1单词，2句子，3段落,4 问答题,14 转述题
  evaluatingText?: string;   // 需要评测的文本,单词,段落,句子才有 (4 问答题,14 转述题 不需要此字段)
  para?: string;             // 问答题情景字段（4：问答题专有，其他类型的题，此字段可为空）
  quest_ans?: string;        // 问题的文本（4：问答题专有，其他类型的题，此字段可为空）
  Im?: number[];               // 所有可能的答案（4 问答题，14 转述题 专有，其他类型的题，此字段可为空）
  key?: number[];              // 关键字(4 问答题，14 转述题  专有，其他类型的题，此字段可为空)
};
export function startRecord(data: startRecordParams) {
  if (!handleHybrid) {
    console.error('hybrid is undefined')
    return
  }
  (<HybridFunc>handleHybrid)('TKEvaluatingRecordStart', data)
}

/**
 * @description 结束录音
 * @param {*} data
 */

interface endRecordParams {
  reason: number;              //必填,1:手动结束;2:自动结束
}
export function endRecord(data: endRecordParams) {
  if (!handleHybrid) {
    console.error('hybrid is undefined')
    return
  }
  (<HybridFunc>handleHybrid)('TKEvaluatingRecordEnd', data)
}

/**
 * @description 播放录音
 * @param {Object} data
 * @param {Number} data.remote    //必填,播放地址类型.  0:播放App本地音频文件;  1:播放网络音频文件
 * @param {String} data.audio    //必填,播放地址,可以是本地,也可以是网络地址
 * @param {Function} callback
 */
interface playAudioZybParams {
  remote: string;
  audio: string;
}
export function playAudioZyb(data: playAudioZybParams, callback: Function) {
  if (!handleHybrid) {
    console.error('hybrid is undefined');
    return
  }

  function hanlder(res?: any, callbackName?: string) {
    console.log(res);
    // 添加通用remove方法
    let code = parseInt(res.code) || 0;
    switch (code) {
      case 1: // 开始播放
      case 2: // 正在播放
        callback.call(this, res);
        (<any>hanlder)['remove'] = () => { };
        break;

      case 3: // 3:播放完成,4:播放失败,其他
      case 4:
        callback.call(this, res);
        (<any>hanlder)['remove'] = (callbackName: any) => {
          if (!!callbackName && window[callbackName]) {
            delete window[callbackName];
          }
        };
        break;
    }
  }
  (<HybridFunc>handleHybrid)('ZybPlayAudio', data, hanlder);
}

/**
 * @description 暂停播放录音
 */
export function pauseAudioZyb() {
  if (!handleHybrid) {
    console.error('hybrid is undefined')
    return
  };
  (<HybridFunc>handleHybrid)('ZybPausePlayAudio');
}

/**
 * @description 停止播放
 */
export function stopAudioZyb() {
  if (!handleHybrid) {
    console.error('hybrid is undefined')
    return
  };
  (<HybridFunc>handleHybrid)('ZybStopPlayAudio');
}

// 存放playAudio播放的音频时创建的callbackName,以便在自定义remove方法中删除
let audioCallbackList: string[] = [];

/*
 * @description 一课新增 播放录音 可以本地
 * 1.组合success, error, complete, notFound, interrupt成一个回调函数传送给端，通过端返回的data.code执行相应的回调函数
 * 2.在回调函数上面添加自定义删除方法，自定义判断什么时机删除挂在window下面的回调函数
 * 3.用全局变量audioCallbackList存储 上一次和本次播放音频时，创建的callbackName（回调函数名），用于播放打断时，删除回调函数
 * 4.自定义remove方法. success时候不删除回调函数;interrupt:删除上一次的回调函数;其他：删除本次的回调函数
 */
interface playAudioParams {
  data: any;
  success?: Function;
  complete?: Function;
  notFound?: Function;
  interrupt?: Function;
  error?: Function;
};
export function playAudio(options: playAudioParams) {
  if (!handleHybrid) {
    console.error('hybrid is undefined')
    return
  }

  let { data, success, error, complete, notFound, interrupt } = options
  if (!data || !data.srcName || !tools.trim(data.srcName)) {
    console.error('srcName is undefined')
    return
  }

  /**
   * 组装callback
   */
  interface callbackIncludeRemove {
    (response: any, callbackName: string): void;
    remove?: Function;
  }
  function getSuccessCallback(success: Function, complete: Function, error: Function, notFound: Function, interrupt: Function ) {
    let _callback: callbackIncludeRemove;
    if(Type.isFunction(success) || Type.isFunction(complete) || Type.isFunction(error)) {
      _callback = function (response: any, callbackName: string) {
        // 添加通用remove方法
        _callback.remove = (callbackName: any) => {
          if (!!callbackName && window[callbackName]) {
            delete window[callbackName]
          }
          audioCallbackList = [];
        }
        // 判断返回值状态,执行相应的回调函数
        if (response) {
          switch (response.code) {
            case COMPLETE: // 播放完成
              Type.isFunction(complete) && complete.call(window, response)
              break
            case ERROR: // 播放失败
              Type.isFunction(error) && error.call(window, response)
              break
            case NOT_FOUND: // 播放action不存在
              Type.isFunction(notFound) && notFound.call(window, response)
              break
            case SUCCESS: // 开始成功播放
              Type.isFunction(success) && success.call(window, response)
              audioCallbackList.push(callbackName)
              _callback['remove'] = (callbackName: string) => { }
              break
            case INTERRUPT:
              Type.isFunction(interrupt) && interrupt.call(window, response)
              _callback['remove'] = (callbackName: string) => {
                if (!audioCallbackList || audioCallbackList.length < 1) {
                  return
                }
                let preCallbackName: any = audioCallbackList.splice(audioCallbackList.length - 2 , 1)[0];
                if (!!preCallbackName && window[preCallbackName]) {
                  // 删除上一个播放的音频
                  delete window[preCallbackName];
                }
              }
              break
          }
        }
      }
    }
    return _callback;
  }
   
  let successCallback = getSuccessCallback(success, complete, error, notFound, interrupt);
  (<HybridFunc>handleHybrid)('playAudio', data, successCallback)
}

/**
 * 一课新增停止播放
 * @param {Object} options
 */
interface stopAudioParams {
  data?: any;
  success?: Function;
  notFound?: Function;
}
export function stopAudio(options: stopAudioParams = {}) {
  if (!handleHybrid) {
    console.error('hybrid is undefined')
    return
  }

  var { data, success, notFound } = options
  if (!data || !data.srcName) {
    data = {}
  }
  var callback = createHybridCallback(success, notFound);
    (<HybridFunc>handleHybrid)('closeWebAudio', data, callback);
}
