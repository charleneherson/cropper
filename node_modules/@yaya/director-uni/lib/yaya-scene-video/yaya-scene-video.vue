<template>
  <view class="scene">
    <video
      v-if="raw && isShowVideo"
      id="video-content"
      class="video-content"
      objectFit="contain"
      :autoplay="autoplayFlag"
      :muted="false"
      :src="scene.raw.ext.url"
      :controls="showControls"
      :enable-progress-gesture="false"
      :enable-play-gesture="isPlayBack"
      :vslide-gesture-in-fullscreen="false"
      :show-play-btn="true"
      :show-progress="true"
      :show-fullscreen-btn="false"
      :show-center-play-btn="false"
      @play="onVideoPlay"
      @pause="onVideoPause"
      @timeupdate="onVideoTimeUpdate"
      @waiting="onVideoWaiting"
      @loadedmetadata="loadedmetadata"
      @error="onVideoError"
      @ended="onVideoEnd"
    ></video>
  </view>
</template>
<script>
import yayaScene from "../yaya-scene/yaya-scene.vue";
// 视频帧命中判定的时间差
const VideoTimeFrameSpan = 0.2;

export default {
  name: "yayaSceneVideo",
  extends: yayaScene,
  props: {},
  computed: {
    showControls() {
      return !(
        this.scene &&
        this.scene.raw &&
        this.scene.raw.ext.isTransferVideo
      );
    }
  },
  data() {
    return {
      videoContext: null,
      hotspotsCache: [],
      videoPlayedTime: 0,
      videoPlayStartTime: 0,
      videoPlayStopTime: 0,
      isShowVideo: false,
      autoplayFlag: false,
    };
  },
  mounted() {
    if(this.scene.raw.ext.isTransferVideo) {
      this.isShowVideo = true;
      this.autoplayFlag = true;
    }
    this.scene.onPause(payload => {
      if (payload.isIntercepted || payload.pauseLastVideo) {
        this.videoContext && this.videoContext.pause();
      }
    });
    this.scene.onResume(payload => {
      this.videoContext && this.videoContext.play();
    });
    this.scene.onStart(() => {
      this.isShowVideo = true;
      this.start();
      if (this.scene.raw && this.scene.raw.hotspots) {
        const hotspots = this.scene.raw.hotspots;
        this.hotspotsCache = hotspots.map(v => {
          return { ...v, isHit: false };
        });
      }
      this.videoContext = uni.createVideoContext("video-content", this);
      this.$nextTick(() => {
        this.videoContext && this.videoContext.play();
      });
    });
    this.scene.onDestroy(() => {
      this.interact("sceneDestroy", {
        scene: this.scene,
        stayedTime: this.stayedTime,
        videoPlayedTime: this.videoPlayedTime
      });
    });
  },
  destroyed() {},
  onReady() {},
  methods: {
    onVideoPlay() {
      this.interact("videoPlay");
      this.videoPlayStartTime = +new Date();
    },
    onVideoPause() {
      this.interact("videoPause");
      this.videoPlayedTime = +new Date() - this.videoPlayStartTime;
    },
    onVideoTimeUpdate(ev) {
      const hotspot = this._getHotspot(ev.detail.currentTime);
      if (hotspot && !hotspot.isHit) {
        hotspot.isHit = true;
        this.act(hotspot.action);
      }
    },
    onVideoWaiting(e) {
      console.log('waitingwaitingwaitingwaiting');
      console.log(e);
    },
    loadedmetadata(e) {
      console.log('loadedmetadataloadedmetadataloadedmetadataloadedmetadataloadedmetadata');
      console.log(e);
    },
    onVideoError() {
      console.error(e);
    },
    onVideoEnd() {
      this.videoPlayedTime = +new Date() - this.videoPlayStartTime;
      setTimeout(()=>{
        this.isShowVideo = false;
      },700);
      this.act(this.scene.actions.complete);
    },
    _getHotspot(t) {
      for (let i = 0; i < this.hotspotsCache.length; i++) {
        const hotspotCache = this.hotspotsCache[i];
        if (Math.abs(hotspotCache.timestamp - t) < VideoTimeFrameSpan) {
          return hotspotCache;
        }
      }
      return null;
    }
  }
};
</script>
<style  lang="scss" scoped>
.scene {
  width: 100vw;
  height: 100vh;
}
.video-content {
  width: 100%;
  height: 100%;
}
</style>
