import CryptoJS from 'crypto-js/crypto-js'
// import aes from 'crypto-js/aes'
// import padPkcs7 from 'crypto-js/pad-pkcs7'
// import encUTf from 'crypto-js/enc-utf8'

function trim(str){
  return str.replace(/^(\s|\u00A0)+/,'').replace(/(\s|\u00A0)+$/,'');   
}
function isArray(o){
  return Object.prototype.toString.call(o)== '[object Array]';
}
// 获取wx_uid
function getwxuid() {
  return uni.getStorageSync('wx_user') ? uni.getStorageSync('wx_user') : '-1'
}
function getSystem() {
  uni.getSystemInfo({
    success: res => {
      console.log('getSystem:', res);
      const {
        system,
        model
      } = res;
    }
  });
}
//编码access-key
// ak:  access-key 必须，使用AES  128bit  CBC模式加密字符串token后base64的结果。
//   密钥使用16位固定串"zyb.2015ZYB.2018"
//    token字符串为  ref-text[0]内容  +  "@"  +  当前服务器时间戳，字符串结尾使用空格补齐到长度为16的倍数
//  token示例例：Hello,  I'm  Zoom.@1537439494
function gen_key(refText) {
  if(isArray(refText)) {
    refText = refText[0];
  }
  console.log(`rt:${refText}`);
  const aes_key="zyb.2015ZYB.2018";
  let line = `${trim(refText)}@${+new Date()}`;
  let temp;
  if(line.length != 16) {
    temp = 16 - line.length % 16;
  }
  for(let i = 0; i < temp;i++) {
    line+=" "
  }  
  console.log(`Voice SDK Line length: ${line.length}`);
  var key = CryptoJS.enc.Utf8.parse(aes_key);
  var iv = CryptoJS.enc.Utf8.parse(aes_key);
  const encrypted = CryptoJS.AES.encrypt(line, key, {
    iv: iv,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
  });
  // 已经是base64
  const temp_text = encrypted.toString();
	return temp_text;
}

// 处理请求参数
export function formatParam(rt,st) {
  let str='';
  // if(isArray(rt)) {
  //   rt = JSON.stringify(rt);
  // }
  console.log(isArray(rt));
  console.log(rt);
  const param = {
    rt: rt,
    st,
    fr: 'yaya_chinese_miapp',
    uid: getwxuid(),
    cuid: 'yaya_chinese_miapp',
    fm: 'mp3',
    ak: gen_key(rt),
    syllable: 1,
    phdet: 1,
  };
  return `content-type=${encodeURIComponent('audio/x-raw')}&param=${encodeURIComponent(JSON.stringify(param))}`;
}

export function checkNetworkType(data = {}) {
  return new Promise((resolve, reject) => {
    uni.getNetworkType({
      success(res) {
        const networkType = res.networkType;
        if (networkType === "none") {
          resolve(res);
          uni.showToast({
            title: "请检查网络连接~",
            icon: "none"
          });
          return;
        } 
      }
    });
  })
}
