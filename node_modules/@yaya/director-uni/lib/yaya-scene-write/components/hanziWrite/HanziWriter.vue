<template>
  <view
    class="container"
    id="#write-canvas-container"
    :style="{
      width: width + 'px',
      height: height + 'px',
      backgroundImage: backgroundImage,
    }"
  >
    <!--汉字展示层-->
    <canvas
      id="writer-canvas"
      type="2d"
      v-show="show"
      canvas-id="writer-canvas"
      :style="{ width: width + 'px', height: height + 'px' }"
    />
    <!-- 用户绘制层，分层避免卡顿问题-->
    <canvas
      v-show="show"
      id="writer-canvas-user"
      type="2d"
      canvas-id="writer-canvas-user"
      :style="{ width: width + 'px', height: height + 'px' }"
      @touchstart.stop.prevent="_touchStart"
      @touchcancel.stop.prevent="_touchEnd"
      @touchend.stop.prevent="_touchEnd"
      @touchmove.stop.prevent="_touchMove"
    />
  </view>
</template>
<script>
export default {
  props: {
    height: {
      type: Number,
      value: 300,
    },
    width: {
      type: Number,
      value: 300,
    },
    backgroundImage: {
      type: String,
      default: "",
      option: {},
    },
    show: {
      type: Boolean,
      value: true,
    },
  },
  data() {
    return {
      isQuizzing: false,
      rect: null,
      options: null,
      painting: false,
      userCanvas: null,
      counter: 1,
      userStroke: [],
    };
  },
  mounted() {
    this.createSelectorQuery()
      .select("#writer-canvas-user")
      .fields({ node: true, size: true })
      .exec((res) => {
        const canvas = res[0].node;
        const ctx = canvas.getContext("2d");
        const dpr = wx.getSystemInfoSync().pixelRatio;
        canvas.height = this.height * dpr;
        canvas.width = this.width * dpr;
        ctx.scale(dpr, dpr);

        this.userCanvas = canvas;
      });
  },
  methods: {
    connectContext(hanziWriter) {
      this.hanziWriter = hanziWriter;
      this.options = hanziWriter.writer._options;
    },
    disconnectContext() {
      if (this.hanziWriter) {
        this.hanziWriter = undefined;
      }
    },
    _touchStart(e) {
      this._getClientBoundingRect().then((rect) => {
        this.rect = rect;
        this.painting = true;
        const quiz = this.hanziWriter.writer._quiz;
        if (quiz._options.onStartUserStroke) {
          quiz._options.onStartUserStroke({
            character: quiz._character.symbol,
            strokeNum: quiz._currentStrokeIndex,
            characterStrokes: quiz._returnCharacterStrokes,
            strokesRemaining:
              quiz._character.strokes.length - quiz._currentStrokeIndex - 1,
          });
        }
        let x = e.touches[0].clientX - this.rect.left;
        let y = e.touches[0].clientY - this.rect.top;
        this.lastPoint = { x: x, y: y };
        const points = this.hanziWriter._options.addPoint(this.lastPoint); //补点操作
        this.userStroke.push(...points);
      });
    },
    _touchMove(e) {
      if (this.painting) {
        if (this.counter < this.options.quizInterval) return this.counter++;
        this.counter = 0;
        let x = e.touches[0].clientX - this.rect.left;
        let y = e.touches[0].clientY - this.rect.top;
        let newPoint = { x: x, y: y };
        if (!this.ecceedMiniDistance(newPoint, this.lastPoint)) return;
        const points = this.hanziWriter._options.addPoint(newPoint); //补点操作
        this.userStroke.push(...points);
        const draw =
          this.hanziWriter._options.drawUserStrokeAction || this.drawLine;
        const ctx = this.userCanvas.getContext("2d");
        ctx.save();
        //  同步两个渲染层的坐标系
        const positioner = this.hanziWriter.writer._positioner;
        ctx.translate(
          positioner.xOffset,
          positioner.height - positioner.yOffset
        );
        ctx.transform(1, 0, 0, -1, 0, 0);
        ctx.scale(positioner.scale, positioner.scale);

        //补点操作
        if (this.userStroke.length - points.length === 1) {
          draw(ctx, [positioner.convertExternalPoint(this.lastPoint)]);
        }
        draw(ctx, [
          ...points.map((ele) => positioner.convertExternalPoint(ele)),
        ]);
        ctx.restore();
        this.lastPoint = newPoint;

        //原始
        // draw(ctx, [
        //   positioner.convertExternalPoint(this.lastPoint),
        //   positioner.convertExternalPoint(newPoint),
        // ]);
        // ctx.restore();
        // this.lastPoint = newPoint;
      }
    },
    ecceedMiniDistance(startPoint, endPoint) {
      const miniDistance = this.options.miniDistance || 0;
      const difX = endPoint.x - startPoint.x;
      const difY = endPoint.y - startPoint.y;
      if (difY * difY + difX * difX > miniDistance * miniDistance) {
        return true;
      }
      return false;
    },
    _touchEnd(e) {
      this.painting = false;
      // 同步用户绘制笔迹到汉字层，并清空用户笔迹层
      this.hanziWriter.syncUserStroke(this.userStroke.slice(0));
      this.userStroke = [];
      const ctx = this.userCanvas.getContext("2d");
      ctx.clearRect(0, 0, this.width, this.height);
    },
    drawLine(ctx, points) {
      // todo 如果需要画线模式，这里需要读取线的样式
      ctx.lineWidth = 3;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.beginPath();
      const start = points[0];
      const remainingPoints = points.slice(1);
      ctx.moveTo(start.x, start.y);
      remainingPoints.forEach((point) => {
        ctx.lineTo(point.x, point.y);
      });
      ctx.stroke();
    },
    setIsQuizzing(isQuizzing) {
      this.isQuizzing = isQuizzing;
    },
    _getClientBoundingRect() {
      return new Promise((resolve) => {
        this.createSelectorQuery("#writer-canvas-user")
          .select("#writer-canvas-user")
          .boundingClientRect((rect) => {
            resolve(rect);
          })
          .exec();
      });
    },
  },
};
</script>
<style lang="scss" scoped>
.container {
  position: relative;
  background-size: cover;
}
canvas {
  position: absolute;
}

.blocker {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
}
</style>
