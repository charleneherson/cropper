const strokeMatches = require('./strokeMatches');
const UserStroke = require('./models/UserStroke');
const {callIfExists, counter} = require('./utils');
const quizActions = require('./quizActions');
const geometry = require('./geometry');
const characterActions = require('./characterActions');


const getDrawnPath = (userStroke, positioner) => ({
  pathString: geometry.getPathString(userStroke.externalPoints),
  points: userStroke.points.map(point => geometry.round(point)),
  wrapperAxisPoints: userStroke.points.map(point => geometry.round(point)).map(point => positioner.convertBackExternalPoint(point))
});


/**
 *
 *
 * @param {*} character
 * @param {*} renderState
 * @param {*} positioner
 * @param {import('../index').options} options
 */
function Quiz(character, renderState, positioner, options) {
  this._character = character;
  this._returnCharacterStrokes = character.strokes.map(ele => {
    ele.wrapperAxisPoints = ele.points.map(point => positioner.convertBackExternalPoint(point))
    return ele
  })
  this._renderState = renderState;
  this._isActive = false;
  this._positioner = positioner;
  this._counter = options.quizInterval
  this._quizInterval = options.quizInterval
  this._keepUserStrokeAfterSuccess = options.keepUserStrokeAfterSuccess
}

Quiz.prototype.startQuiz = function(options) {
  this._isActive = true;
  this._options = options;
  this._currentStrokeIndex = 0;
  this._numRecentMistakes = 0;
  this._totalMistakes = 0;
  this._drawnStrokes = [];
  this._renderState.run(quizActions.startQuiz(this._character, options.strokeFadeDuration));
  callIfExists(this._options.onStartStroke, {
  character: this._character.symbol,
  strokeNum: this._currentStrokeIndex,
  characterStrokes: this._returnCharacterStrokes,
  strokesRemaining: this._character.strokes.length - this._currentStrokeIndex - 1,
});

};

Quiz.prototype.startUserStroke = function(externalPoint) {
  console.log('startUserStroke');
  const point = this._positioner.convertExternalPoint(externalPoint);
  if (!this._isActive) return null;
  if (this._userStroke) return this.endUserStroke();
  const strokeId = counter();
  this._userStroke = new UserStroke(strokeId, point, externalPoint);
  callIfExists(this._options.onStartUserStroke, {
    character: this._character.symbol,
    strokeNum: this._currentStrokeIndex,
    characterStrokes: this._returnCharacterStrokes,
    strokesRemaining: this._character.strokes.length - this._currentStrokeIndex - 1,
  });
  this._renderState.run(
    quizActions.startUserStroke(strokeId, point),
  );
};

Quiz.prototype.continueUserStroke = function(externalPoint) {
  if (this._counter < this._quizInterval) return this._counter ++ 
  this._counter = 0
  if (!this._userStroke) return;
  const point = this._positioner.convertExternalPoint(externalPoint);
  this._userStroke.appendPoint(point, externalPoint);
  const nextPoints = this._userStroke.points.slice(0);
  this._renderState.run(quizActions.updateUserStroke(this._userStroke.id, nextPoints));
};

// 渲染层分离的时候，直接同步用户绘制路径到画布上
Quiz.prototype.syncUserStroke = function(externalPoints) {
  console.log('externalPoints', externalPoints)
  const points = externalPoints.map(externalPoint => this._positioner.convertExternalPoint(externalPoint));
  const strokeId = counter();
  this._userStroke = new UserStroke(strokeId, points[0], externalPoints[0]);
  this._renderState.run(
    quizActions.startUserStroke(strokeId, points[0]),
  );
  this._userStroke.appendPoints(points.slice(1), externalPoints.slice(1));
  const nextPoints = this._userStroke.points.slice(0);
  this._renderState.run(quizActions.updateUserStroke(this._userStroke.id, nextPoints));
  this.endUserStroke()
};

Quiz.prototype.endUserStroke = function() {
  if (!this._userStroke) return;
  // skip single-point strokes
  if ( !this._options.checkSingleStroke && this._userStroke.points.length === 1) {
    this._renderState.run(quizActions.removeUserStroke(this._userStroke.id, this._options.drawingFadeDuration));
    this._userStroke = null;
    return;
  }

  const currentStroke = this._getCurrentStroke();
  const isOutlineVisible = this._renderState.state.character.outline.opacity > 0;
  const isMatch = strokeMatches(this._userStroke, this._character, this._currentStrokeIndex, {
    isOutlineVisible,
    leniency: this._options.leniency,
  });

  if (isMatch) {
    if (!this._keepUserStrokeAfterSuccess) this._renderState.run(quizActions.removeUserStroke(this._userStroke.id, this._options.drawingFadeDuration));
    this._handleSuccess(currentStroke);
  } else {
    this._renderState.run(quizActions.removeUserStroke(this._userStroke.id, this._options.drawingFadeDuration));
    this._handleFailure();  
    if (this._numRecentMistakes >= this._options.showHintAfterMisses) {
      this._renderState.run(
        quizActions.highlightStroke(currentStroke, this._options.highlightColor, this._options.strokeHighlightSpeed),
      );
    }
  }
  this._userStroke = null;
};

Quiz.prototype.highlightStroke = function(stroke) {
  this._renderState.run(
    quizActions.highlightStroke(stroke, this._options.highlightColor, this._options.strokeHighlightSpeed),
  );
}

Quiz.prototype.highlightCompleteChar = function() {
  this._renderState.run(
    quizActions.highlightStroke(
        this._character,
        this._options.highlightCompleteColor,
        this._options.strokeHighlightDuration * 2,
    ),
  );
}

Quiz.prototype.cancel = function() {
  this._isActive = false;
  if (this._userStroke) {
    this._renderState.run(quizActions.removeUserStroke(this._userStroke.id, this._options.drawingFadeDuration));
  }
};

Quiz.prototype._handleSuccess = function(stroke) {
  callIfExists(this._options.onCorrectStroke, {
    character: this._character.symbol,
    strokeNum: this._currentStrokeIndex,
    characterStrokes: this._returnCharacterStrokes,
    mistakesOnStroke: this._numRecentMistakes,
    totalMistakes: this._totalMistakes,
    strokesRemaining: this._character.strokes.length - this._currentStrokeIndex - 1,
    drawnPath: getDrawnPath(this._userStroke, this._positioner),
  });
  let animation = characterActions.showStroke('main', this._currentStrokeIndex, this._options.strokeFadeDuration);
  this._currentStrokeIndex += 1;
  this._numRecentMistakes = 0;

  if (this._currentStrokeIndex === this._character.strokes.length) {
    this._isActive = false;
    callIfExists(this._options.onComplete, {
      userStrokes:  this._renderState.state.userStrokes,
      character: this._character.symbol,
      characterStrokes: this._returnCharacterStrokes,
      totalMistakes: this._totalMistakes,
    });
    if (this._options.highlightOnComplete) {
      animation = animation.concat(quizActions.highlightCompleteChar(
        this._character,
        this._options.highlightCompleteColor,
        this._options.strokeHighlightDuration * 2,
      ));
    }
  }
  this._renderState.run(animation);
};

Quiz.prototype._handleFailure = function() {
  this._numRecentMistakes += 1;
  this._totalMistakes += 1;
  callIfExists(this._options.onMistake, {
    character: this._character.symbol,
    characterStrokes: this._returnCharacterStrokes,
    strokeNum: this._currentStrokeIndex,
    mistakesOnStroke: this._numRecentMistakes,
    totalMistakes: this._totalMistakes,
    strokesRemaining: this._character.strokes.length - this._currentStrokeIndex,
    drawnPath: getDrawnPath(this._userStroke, this._positioner),
  });
};

Quiz.prototype._getCurrentStroke = function() {
  return this._character.strokes[this._currentStrokeIndex];
};

module.exports = Quiz;
