/**
 * FE通过scheme拦截的方式向native主动发送消息
 * 例如：<iframe src="iknowhybrid://toast?data={parmas: \"test\"}&__callback__=__cb__common__32423__2"></iframe>
 * 如果native收到消息后需要将处理结果回传给FE，
 * 通过调用FE发送消息时参数中携带的回调函数，
 * 这个回调函数挂载在window上面。
 * 例如：window.__cb__common__32423__2(res);
 */

import Type from './type'
import tools from './tool'
import { NOT_FOUND } from './statusCode'
import { isInApp, production, UNKNOW } from './system'
// import { addLog } from './tool'
const win: any = window;
const isLocal = /(localhost|127.0.0.1)/.test(location.origin)
let __cb__: any = null

// 创建hybrid
function createHybrid() {
    var protocol = !isLocal ? 'iknowhybrid://' : '/hybridaction/'
    var callbackCount = 0

    function createBridge() {
        var bridge = document.createElement('iframe')
        bridge.setAttribute('style', 'display:none;')
        bridge.setAttribute('height', '0px')
        bridge.setAttribute('width', '0px')
        bridge.setAttribute('frameborder', '0')
        document.documentElement.appendChild(bridge)
        return bridge
    }

    function buildUrl(action: any, params: any, callback: any) {
        var url = protocol + action + '?'
        var id = tools.guid()
        url += 'data=' + encodeURIComponent(JSON.stringify(params || {}))
        if (callback) {
            var callbackName = '__cb__' + action + '__' + id + '__' + callbackCount++
            if (isLocal) {
                __cb__ = callbackName
            }
            win[callbackName] = function() {
                let args: any = arguments;
                args = [].slice.call(args)
                // 回调名称
                args.push(callbackName)
                callback && callback.apply(window, args)
                /**
                 * Des:删除回调
                 * 1.如果没有remove方法，直接删除
                 * 2.如果有remove方法，调用remove方法删除。自定义删除时机
                 */
                if (Type.isFunction(callback.remove)) {
                    !!callbackName && callback.remove.apply(callback, [callbackName])
                } else {
                    delete win[callbackName]
                }
            }
            url += '&__callback__=' + callbackName
        }
        return url
    }

    return function (action: any, params?: any, callback?: Function) {
        // 测试使用 显示日志调用
        // addLog(`oldJsBridge, action=${action}`);
        let bridge: any = createBridge()
        if (params && Object.prototype.toString.call(params) === '[object Function]') {
            callback = params
            params = {}
        }
        var url = buildUrl(action, params, callback)

        isLocal && (bridge.onload = window[__cb__])
        __cb__ = null

        bridge.setAttribute('src', url);
        (function (bridge) {
            // 3000ms后删除创建的iframe,//时间随机给的
            bridge.timer = setTimeout(() => {
                bridge.parentNode.removeChild(bridge)
                clearTimeout(bridge.timer)
            }, 3000)
        })(bridge);
    }
}

/**
 * 调用app的hybrid方法
 */
win.hybrid_sdk_framekey = new Date().getTime() + tools.guid()
function _h5PluginAction (action: any, params: any, callback: any) {
  if (params && Object.prototype.toString.call(params) === '[object Function]') {
    callback = params;
    params = {};
  }
  params = params || {};
  params.hybrid_sdk_framekey = win.hybrid_sdk_framekey;
  win.parent.h5PluginAction(action, params, callback);
}
export let hybrid = isInApp
    ? createHybrid()
    : production === UNKNOW
        ? function(){}
        : _h5PluginAction;

if (isLocal) {
    console.log('本地环境，createHybrid');
    hybrid = createHybrid();
}

/**
 * 创建hybrid 回调方法，为了兼容以前的接口，和win端的h5PluginAction,不能修改createHybrid
 * @param {Function} success  成功调用action
 * @param {Function} notFound 没有找到action
 */
export function createHybridCallback(success: Function, notFound: Function) {
    var callback = null
    if (Type.isFunction(success) || Type.isFunction(notFound)) {
        callback = function (response: any) {
            if (!!response && response.code === NOT_FOUND) {
                Type.isFunction(notFound) && notFound.call(window, response)
            } else {
                Type.isFunction(success) && success.call(window, response)
            }
        }
    }
    return callback
}
